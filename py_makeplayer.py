#!/opt/local/bin/python

from random import randint
import os

#Configuration settings
NUMRANDFILES = 8
PL_NUMCHANNELS = 3*3
PL_NUMSIDCHANNELS = 6   #3 for mono sid, 6 for stereo sid, or 9 for tripple sid...
PL_NUMSONGPOSITIONS = 256
PL_ZPSTART = 2
if PL_NUMSIDCHANNELS > 0:
    PL_SID1_BASE = 0xd400
if PL_NUMSIDCHANNELS >= 3:
    PL_SID1_BASE = 0xd500
if PL_NUMSIDCHANNELS >= 6:
    PL_SID1_BASE = 0xde00


#Validate constants
if (PL_NUMSIDCHANNELS > PL_NUMCHANNELS):
    quit("ERROR in "+os.path.basename(__file__)+":\tCan't have more sid channels than there are editor channels. Check how the constants are set up!")


#Variable init
zpcounter = PL_ZPSTART
pf = ""
df = ""

#Generate data file
df += """\
; droneMON PLAYER DATA

		; align code to page border for speed increase
		!align 255, 0

pl_seqptrs_lo:
"""
for i in range(PL_NUMSONGPOSITIONS):
    df += "	   !byte <pl_seq_"+'{:02X}'.format(i)+"\n"
df += "\n"
df += "pl_seqptrs_hi:\n"
for i in range(PL_NUMSONGPOSITIONS):
    df += "	   !byte >pl_seq_"+'{:02X}'.format(i)+"\n"
df += "\n"
for i in range(PL_NUMCHANNELS):
    df += "pl_chn"+str(i).zfill(2)+"_seqlist:\n"
    if (i == 0):
        df += "		!byte 1\n"
        df += "		!byte 2\n"
        df += "		!byte 3\n"
        df += "		!byte 4\n"
        df += "		!fill PL_NUMSONGPOSITIONS-4, 0\n"
    else:    
        df += "		!fill PL_NUMSONGPOSITIONS, 0\n"
    # df += "        !for i, PL_NUMSONGPOSITIONS {!byte i-1}\n"
df += "\n"
for i in range(PL_NUMSONGPOSITIONS):
    df += "pl_seq_"+'{:02X}'.format(i)+":\n"
    if (i == 1):
        df += "        !byte %10011111\t;One note and then 32 steps of empty sequence\n"
        df += "        !byte $80 + 12*4\t;The note + TRIG\n"
    else:
        df += "        !byte %00011111\t;32 steps of empty sequence\n"
    # if (i == 0):
    #     df += "        lda #0\n"
    # df += "        rts\n"
df += "\n"




#Generate code file
pf += """\
; droneMON PLAYER CODE

; This file is autogenerated by """+os.path.basename(__file__)+""" and deleted when issuing a make clean,
; so please don't mess with it directly. Make changes in the python script instead.

;Design choice: No sidbuffer (parameters make variation possible instead)

;============================
;Config constants

PL_NUMCHANNELS = """+str(PL_NUMCHANNELS)+"""
PL_NUMSIDCHANNELS = """+str(PL_NUMSIDCHANNELS)+"""
PL_NUMSONGPOSITIONS = """+str(PL_NUMSONGPOSITIONS)+"""

"""
pf += ";Global (for all channels) variables\n"
nbytes = 1
pf += "PL_ZP_START = $"+'{:02X}'.format(zpcounter)+"\t;"+str(nbytes)+" bytes\n"
#PL_ZP_SONGPOS = $"""+'{:02X}'.format(zpcounter)+"\n"
zpcounter += 1
pf += "PL_ZP_TICKCOUNTER = $"+'{:02X}'.format(zpcounter)+"\t;"+str(nbytes)+" bytes\n"
zpcounter += 1
#pf += "PL_ZP_SONGPOS = $"+'{:02X}'.format(zpcounter)+"\t;"+str(nbytes)+" bytes\n"
#zpcounter += 1
pf += "PL_ZP_SEQPOS = $"+'{:02X}'.format(zpcounter)+"\t;"+str(nbytes)+" bytes\n"
zpcounter += 1
pf += "\n"

#Sequence parsing variables
nbytes = 2
pf += ";Sequence pointers\n"
for i in range(PL_NUMCHANNELS):
    pf += "PL_ZP_CHN"+str(i).zfill(2)+" = $"+'{:02X}'.format(zpcounter)+"\t;"+str(nbytes)+" bytes\n"
    zpcounter += nbytes
pf += "\n"

nbytes = 1
pf += ";Song position counters (separate for each channel, to allow for Ableton Live mode style)\n"
for i in range(PL_NUMCHANNELS):
    pf += "PL_ZP_CHN"+str(i).zfill(2)+"_SONGPOS = $"+'{:02X}'.format(zpcounter)+"\t;"+str(nbytes)+" bytes\n"
    zpcounter += nbytes
pf += "\n"
#pf += ";Song position counter (one global counter for all channels)\n"
#pf += "PL_ZP_SONGPOS = $"+'{:02X}'.format(zpcounter)+"\n"
#pf += "\n"

#nbytes = 1
#pf += ";Internal sequence position counters (separate for each channel)\n"
#for i in range(PL_NUMCHANNELS):
#    pf += "PL_ZP_CHN"+str(i).zfill(2)+"_SEQPOS = $"+'{:02X}'.format(zpcounter)+"\t;"+str(nbytes)+" bytes\n"
#    zpcounter += nbytes
#pf += "\n"
#pf += ";Internal sequence pointer counter (one global counter for all channels)\n"
#pf += "PL_ZP_SEQPOS = $"+'{:02X}'.format(zpcounter)+"\n"
#pf += "\n"

#nbytes = 1
#pf += ";Delay counters (steps, not ticks, between each note)\n"
#for i in range(PL_NUMCHANNELS):
#    pf += "PL_ZP_CHN"+str(i).zfill(2)+"_DELAY = $"+'{:02X}'.format(zpcounter)+"\t;"+str(nbytes)+" bytes\n"
#    zpcounter += nbytes
#pf += "\n"

nbytes = 1
pf += ";Multispeed coefficients (separately for each channel)\n"
for i in range(PL_NUMCHANNELS):
    pf += "PL_ZP_CHN"+str(i).zfill(2)+"_MULSPEED = $"+'{:02X}'.format(zpcounter)+"\t;"+str(nbytes)+" bytes\n"
    zpcounter += nbytes
pf += "\n"

#Sound variables
nbytes = 1
pf += ";Current base NOTE\n"
for i in range(PL_NUMCHANNELS):
    pf += "PL_ZP_CHN"+str(i).zfill(2)+"_BASENOTE = $"+'{:02X}'.format(zpcounter)+"\t;"+str(nbytes)+" bytes\n"
    zpcounter += nbytes
pf += "\n"

nbytes = 1
pf += ";Current relative NOTE\n"
for i in range(PL_NUMCHANNELS):
    pf += "PL_ZP_CHN"+str(i).zfill(2)+"_RELNOTE = $"+'{:02X}'.format(zpcounter)+"\t;"+str(nbytes)+" bytes\n"
    zpcounter += nbytes
pf += "\n"

nbytes = 1
pf += ";Current SC1 (Sound Chunk #1)\n"
for i in range(PL_NUMCHANNELS):
    pf += "PL_ZP_CHN"+str(i).zfill(2)+"_SC1 = $"+'{:02X}'.format(zpcounter)+"\t;"+str(nbytes)+" bytes\n"
    zpcounter += nbytes
pf += "\n"

nbytes = 1
pf += ";Current SC1 ORIGINAL POSITION (Sound Chunk #1)\n"
for i in range(PL_NUMCHANNELS):
    pf += "PL_ZP_CHN"+str(i).zfill(2)+"_SC1_ORGPOS = $"+'{:02X}'.format(zpcounter)+"\t;"+str(nbytes)+" bytes\n"
    zpcounter += nbytes
pf += "\n"

nbytes = 1
pf += ";Current SC2 (Sound Chunk #2)\n"
for i in range(PL_NUMCHANNELS):
    pf += "PL_ZP_CHN"+str(i).zfill(2)+"_SC2 = $"+'{:02X}'.format(zpcounter)+"\t;"+str(nbytes)+" bytes\n"
    zpcounter += nbytes
pf += "\n"


#Some special MIDI variables
nbytes = 1
pf += ";Keep track of current MIDI program used in this channel (0-15)\n"
for i in range(PL_NUMCHANNELS):
    pf += "PL_ZP_CHN"+str(i).zfill(2)+"_MIDI_PROGRAM = $"+'{:02X}'.format(zpcounter)+"\t;"+str(nbytes)+" bytes\n"
    zpcounter += nbytes
pf += "\n"

nbytes = 1
pf += """\
;MIDI VELOCITY for each channel
;Default velocity is 100 (max is 127)
"""
for i in range(PL_NUMCHANNELS):
    pf += "PL_ZP_CHN"+str(i).zfill(2)+"_MIDI_VELOCITY = $"+'{:02X}'.format(zpcounter)+"\t;"+str(nbytes)+" bytes\n"
    zpcounter += nbytes
pf += """
PL_ZP_END = $"""+'{:02X}'.format(zpcounter)+"""

"""
#Sanity checking
if zpcounter > 255:
    quit("ERROR in "+os.path.basename(__file__)+":\tZeropage data overflow!")


pf += """\
;============================
pl_main:

    ;SEND MIDI-CLOCK MESSAGE (ALWAYS 3 ticks per step to fit 24ppqn: pulses per quarter note)


    ;---------------------------
    ; Sequence parsing

		;--------------------
		;Här ska det vara nån tick/step/groove-nånting-kod.
		;Mnja.. Det ska vara shufflespeed mha timerinterruptsen istället.
		;Both MIDI and DIN Sync clocks are sent at a rate of 24 ppqn (pulses per quarter note).
		;a Roland compatible device playing sixteenth notes would have to advance to
		;the next note every time it receives 6 pulses.

		;First check for sequence break (which is when tickcounter = 0)
;		dec PL_ZP_TICKCOUNTER\t;Ranges from 00-c0
;		beq +
:		jmp .noseqbreak
;+
PL_TICKCOUNTER = *+1
        ldy #0
        beq .tick00
        dec PL_TICKCOUNTER
        cpy #3
        beq .tick03_checkpretrig
        jmp .noseqparse

.tick03_checkpretrig:

            ;CHECK IF IT IS TIME TO FETCH NEW SEQUENCE POINTERS
            
            ;Time to fetch new sequence pointers

"""
for i in range(PL_NUMCHANNELS):
    pf += "			;Fetch pointer for chn"+str(i).zfill(2)+"\n"
    pf += "			ldy PL_ZP_CHN"+str(i).zfill(2)+"_SONGPOS\t;Allow separate song positions for each channel (like ableton live mode).\n"
    pf += ";			tya\n"
    pf += ";			jsr ed_printbyte\n"
    pf += "			lax pl_chn"+str(i).zfill(2)+"_seqlist,y\n"
    # if i == 0:
    #     pf += "            jsr ed_printbyte\n"
    pf += "			lda pl_seqptrs_lo,x\n"
    pf += "			sta PL_ZP_CHN"+str(i).zfill(2)+"\n"
    pf += "			lda pl_seqptrs_hi,x\n"
    pf += "			sta PL_ZP_CHN"+str(i).zfill(2)+"+1\n"
    pf += "			inc PL_ZP_CHN"+str(i).zfill(2)+"_SONGPOS\t;Bump\n"
    pf += "\n"
pf += """\
			;Clear seqbreakflag
;			lda #$c0\t;There are ALWAYS 6*32 ticks/clocks in each sequence = compatible with SYNC24/MIDI SYNC
;			sta PL_ZP_TICKCOUNTER
            lda #6
            sta PL_TICKCOUNTER

.noseqbreak:
;---

"""
# Actual sequence parsing
pf += """\


"""
#		;Decide what to do on different player ticks (0 = seqparse, 3 = pretrig, 1,2,4,5 = do nothing)
#        ldx PL_ZP_TICKCOUNTER
#        txa
#        jsr ed_printbyte2
#		lda pl_tickaction,x
#		beq .tick00\t;00 in the table means tick00 (seqparse)
#		bpl .tick03\t;01(-$7f) in the table means tick03 (pretrig)
#       cpx #$ff
#       beq .tick03_fetchseqptrs
#		jmp .doneseqparse\t;ff means there is no sequence parsing to do


#Sequence format
#
# Sequence break is handled by setting the PL_ZP_TICKCOUNTER variable directly from a sound chunk
#
#CTRL:
# b7 - NT   (implies one byte 00-7f = set note only, 80-ff set note+PRETRIG)
# b6 - S1   (implies one byte of sound chunk pointer. If that is in range 80-ff that implies one more byte of PARAMETER)
# b5 - S2   (implies one byte of sound chunk pointer. If that is in range 80-ff that implies one more byte of PARAMETER)
# b4-b0     (...corresponds to a 5bit number of pattern steps until the next one. Max = 32 = one whole sequence)
#
# NT  S1 P  S2
# C-4 4F -- --

# Vad betyder TRIG?
# Betyder det att man kör pretrig för nuvarande sound chunk? Betyder det ett NOTE ON msg för MIDI?
# Nja det betyder väl just pretrig för nuvarande sound chunk. Det är väl just den grejen som behöver en specialare.


# Om det är 3 ticks kvar till nästa så gör man en lookahead.
# (MEN MÅSTE DET ALLTID VARA JUST 3 TICKS? JA KANSKE? FÖR ENKELHETENS SKULL?)
# Använd note range $80+ för att indikera "TRIG" av något.
# Om man alltså hittar TRIG när man gör en lookahead så ska man kolla vidare om:
#   1. Sätts ett nytt instrument i ST1 PÅ DENNA RAD?
#   2. Om ja: Läs från pretrigtabell (ett värde för varje instrument) och JSR'a DIREKT DIT.
#   2. Om nej: Kolla om nuvarande defaultinstrument har PRETRIG

# Om det är 0 ticks var så:
# ...kollar man om ett nytt instrument sätts i ST1

pf += """\
        ;Pretrig (at tick03)
.tick03:
		;--------------------

"""
for i in range(PL_NUMCHANNELS):
    pf += """\
        ;Pre-parse channel """+'{:02X}'.format(i)+"""

"""
        
pf += """
		jmp .doneseqparse

        ;Seqparse (at tick00)
.tick00:
"""
for i in range(PL_NUMCHANNELS):
    # pf += "xyz\n"
    pf += """\
		;--------------------
        ;Parse channel """+'{:02X}'.format(i)+"""
        dec PL_ZP_CHN"""+str(i).zfill(2)+"""_DELAY
        bpl +
            ldy PL_ZP_CHN"""+str(i).zfill(2)+"""_SEQPOS
            lda (PL_ZP_CHN"""+str(i).zfill(2)+"""),y	;Read control byte
            sta $0400+2*40+"""+str(i).zfill(2)+"""
+
        ;OBS: Det måste finnas något sätt att skippa steps i traxxet
        
        \n"""
pf += """\
.doneseqparse:
.noseqparse:

		rts
		;---


;============================
pl_init:
        ;FIRST: Clear all ZP variables
        ldy #PL_ZP_END-PL_ZP_START
        lda #0
-       sta PL_ZP_START-1,y
        dey
        bne -

        ;THEN: Ensure that the first step is executed at once 
		lda #1
		sta PL_ZP_TICKCOUNTER
                
        rts
		;---


"""
#;============================
#pl_tickaction = *-1\t;Make table 1-indexed rather than 0-indexed
#for i in range(32):
#    pf += "		!byte $00\t;$"+'{:02X}'.format(i*6+1)+": Tick 00\n"
#    pf += "		!byte $ff\t;$"+'{:02X}'.format(i*6+2)+": Tick 01\n"
#    pf += "		!byte $ff\t;$"+'{:02X}'.format(i*6+3)+": Tick 02\n"
#    pf += "		!byte $01\t;$"+'{:02X}'.format(i*6+4)+": Tick 03\n"
#    pf += "		!byte $ff\t;$"+'{:02X}'.format(i*6+5)+": Tick 04\n"
#    pf += "		!byte $ff\t;$"+'{:02X}'.format(i*6+6)+": Tick 05\n"
#pf += "		;---\n"
#pf += "\n"




text_file = open("pl_main.a", "w")
text_file.write(pf)
text_file.close()

text_file = open("pl_data.a", "w")
text_file.write(df)
text_file.close()

#Finally, generate some files with random bytes, for watermarking purposes
# for i in range(NUMRANDFILES):
#     rndfile = ""
#     for j in range(randint(1,5)):
#         rndfile += "     !byte $"+'{:02X}'.format(randint(0,255))+"\n"
#     text_file = open("ed_rndfile"+str(i+1)+".a", "w")
#     text_file.write(rndfile)
#     text_file.close()
    

